Object.defineProperty(exports, "__esModule", {
    value: true
});

if (typeof Object.assign !== "function") {
    // Must be writable: true, enumerable: false, configurable: true
    Object.assign = function(target) {
        // .length of function is 2
        if (target == null) {
            // TypeError if undefined or null
            throw new TypeError("Cannot convert undefined or null to object");
        }
        var to = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var nextSource = arguments[index];
            if (nextSource != null) {
                // Skip over if undefined or null
                for (var nextKey in nextSource) {
                    // Avoid bugs when hasOwnProperty is shadowed
                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        return to;
    };
}

function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}

function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}

function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
    if (self === undefined) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}

function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self);
}

function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
        return arr2;
    }
}

function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
}

/* eslint-disable */
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 */
/** Used as the `TypeError` message for "Functions" methods. */ var FUNC_ERROR_TEXT = "Expected a function";

/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";

/** Used as references for various `Number` constants. */ var INFINITY = Infinity;

/** `Object#toString` result references. */ var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", symbolTag = "[object Symbol]";

/** Used to match property names within property paths. */ var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */ var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */ var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) === "object" && global && global.Object === Object && global;

/** Detect free variable `self`. */ var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self && self.Object === Object && self;

/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();

/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString !== "function") {
        try {
            result = !!(value + "");
        } catch (e) {}
    }
    return result;
}

/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];

/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();

/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;

/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;

/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

/** Built-in value references. */ var _Symbol = root.Symbol, splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */ var Map$1 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");

/** Used to convert symbols to primitives and strings. */ var symbolProto = _Symbol ? _Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;

Hash.prototype["delete"] = hashDelete;

Hash.prototype.get = hashGet;

Hash.prototype.has = hashHas;

Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([ key, value ]);
    } else {
        data[index][1] = value;
    }
    return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;

ListCache.prototype["delete"] = listCacheDelete;

ListCache.prototype.get = listCacheGet;

ListCache.prototype.has = listCacheHas;

ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        hash: new Hash(),
        map: new (Map$1 || ListCache)(),
        string: new Hash()
    };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;

MapCache.prototype["delete"] = mapCacheDelete;

MapCache.prototype.get = mapCacheGet;

MapCache.prototype.has = mapCacheHas;

MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */ function baseGet(object, path) {
    path = isKey(path, object) ? [ path ] : castPath(path);
    var index = 0, length = path.length;
    while (object != null && index < length) {
        object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */ function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value === "string") {
        return value;
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */ function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key === "string" ? "string" : "hash"] : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */ function isKey(value, object) {
    if (isArray(value)) {
        return false;
    }
    var type = _typeof(value);
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = _typeof(value);
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */ var stringToPath = memoize(function(string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
        result.push("");
    }
    string.replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */ function toKey(value) {
    if (typeof value === "string" || isSymbol(value)) {
        return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */ function memoize(func, resolver) {
    if (typeof func !== "function" || resolver && typeof resolver !== "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function memoized() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = _typeof(value);
    return !!value && (type == "object" || type == "function");
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && _typeof(value) === "object";
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return _typeof(value) === "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */ function toString(value) {
    return value == null ? "" : baseToString(value);
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    var type = _typeof(value);
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function baseAssignValue(object, key, value) {
    if (key == "__proto__") {
        Object.defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            value: value,
            writable: true
        });
    } else {
        object[key] = value;
    }
}

/** Used to check objects for own properties. */ var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        baseAssignValue(object, key, value);
    }
}

/**
 * The base implementation of `set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */ function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
        return object;
    }
    path = castPath(path, object);
    var length = path.length;
    var lastIndex = length - 1;
    var index = -1;
    var nested = object;
    while (nested != null && ++index < length) {
        var key = toKey(path[index]);
        var newValue = value;
        if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined;
            if (newValue === undefined) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
    }
    return object;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */ function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @see has, hasIn, get, unset
 * @example
 *
 * const object = { 'a': [{ 'b': { 'c': 3 } }] }
 *
 * set(object, 'a[0].b.c', 4)
 * console.log(object.a[0].b.c)
 * // => 4
 *
 * set(object, ['x', '0', 'y', 'z'], 5)
 * console.log(object.x[0].y.z)
 * // => 5
 */ function set$1(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
}

var upperCasePattern = /([A-Z])/g;

function dashify(str) {
    return str.replace(upperCasePattern, dashLower);
}

function dashLower(c) {
    return "-" + c.toLowerCase();
}

function isObject$1(val) {
    return val != null && _typeof(val) === "object" && Array.isArray(val) === false;
}

function inlineStyle(obj) {
    if (obj == null) {
        return "";
    }
    if (typeof obj === "string") {
        return obj;
    }
    if (obj === null || obj === undefined) {
        return "";
    }
    if (!isObject$1(obj)) {
        throw new TypeError("style 只能是一个对象或字符串。");
    }
    return Object.keys(obj).map(function(key) {
        return dashify(key).concat(":").concat(obj[key]);
    }).join(";");
}

var ENV_TYPE = {
    WEAPP: "WEAPP",
    WEB: "WEB",
    RN: "RN",
    SWAN: "SWAN",
    ALIPAY: "ALIPAY",
    TT: "TT"
};

function getEnv() {
    if (typeof tt !== "undefined" && tt.getSystemInfo) {
        return ENV_TYPE.TT;
    }
    if (typeof wx !== "undefined" && wx.getSystemInfo) {
        return ENV_TYPE.WEAPP;
    }
    if (typeof swan !== "undefined" && swan.getSystemInfo) {
        return ENV_TYPE.SWAN;
    }
    if (typeof my !== "undefined" && my.getSystemInfo) {
        return ENV_TYPE.ALIPAY;
    }
    if (typeof global !== "undefined" && global.__fbGenNativeModule) {
        return ENV_TYPE.RN;
    }
    if (typeof window !== "undefined") {
        return ENV_TYPE.WEB;
    }
    return "Unknown environment";
}

function isObject$2(arg) {
    return arg === Object(arg) && typeof arg !== "function";
}

var env = null;

function getOriginal(item) {
    if (env === null) {
        env = getEnv();
    }
    if (isObject$2(item)) {
        return item[env === ENV_TYPE.SWAN ? "privateOriginal" : "$original"] || item;
    }
    return item;
}

var Events = 
/* */
function() {
    function Events(opts) {
        _classCallCheck(this, Events);
        if (typeof opts !== "undefined" && opts.callbacks) {
            this.callbacks = opts.callbacks;
        } else {
            this.callbacks = {};
        }
    }
    _createClass(Events, [ {
        key: "on",
        value: function on(events, callback, context) {
            var calls, event, node, tail, list;
            if (!callback) {
                return this;
            }
            events = events.split(Events.eventSplitter);
            calls = this.callbacks;
            while (event = events.shift()) {
                list = calls[event];
                node = list ? list.tail : {};
                node.next = tail = {};
                node.context = context;
                node.callback = callback;
                calls[event] = {
                    tail: tail,
                    next: list ? list.next : node
                };
            }
            return this;
        }
    }, {
        key: "once",
        value: function once(events, callback, context) {
            var _this = this;
            var wrapper = function wrapper() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }
                callback.apply(_this, args);
                _this.off(events, callback, context);
            };
            this.on(events, wrapper, context);
            return this;
        }
    }, {
        key: "off",
        value: function off(events, callback, context) {
            var event, calls, node, tail, cb, ctx;
            if (!(calls = this.callbacks)) {
                return this;
            }
            if (!(events || callback || context)) {
                delete this.callbacks;
                return this;
            }
            events = events ? events.split(Events.eventSplitter) : Object.keys(calls);
            while (event = events.shift()) {
                node = calls[event];
                delete calls[event];
                if (!node || !(callback || context)) {
                    continue;
                }
                tail = node.tail;
                while ((node = node.next) !== tail) {
                    cb = node.callback;
                    ctx = node.context;
                    if (callback && cb !== callback || context && ctx !== context) {
                        this.on(event, cb, ctx);
                    }
                }
            }
            return this;
        }
    }, {
        key: "trigger",
        value: function trigger(events) {
            var event, node, calls, tail, rest;
            if (!(calls = this.callbacks)) {
                return this;
            }
            events = events.split(Events.eventSplitter);
            rest = [].slice.call(arguments, 1);
            while (event = events.shift()) {
                if (node = calls[event]) {
                    tail = node.tail;
                    while ((node = node.next) !== tail) {
                        node.callback.apply(node.context || this, rest);
                    }
                }
            }
            return this;
        }
    } ]);
    return Events;
}();

Events.eventSplitter = /\s+/;

function render() {}

var onAndSyncApis = {
    onSocketOpen: true,
    onSocketError: true,
    onSocketMessage: true,
    onSocketClose: true,
    onBackgroundAudioPlay: true,
    onBackgroundAudioPause: true,
    onBackgroundAudioStop: true,
    onNetworkStatusChange: true,
    onAccelerometerChange: true,
    onCompassChange: true,
    onBluetoothAdapterStateChange: true,
    onBluetoothDeviceFound: true,
    onBLEConnectionStateChange: true,
    onBLECharacteristicValueChange: true,
    onBeaconUpdate: true,
    onBeaconServiceChange: true,
    onUserCaptureScreen: true,
    onHCEMessage: true,
    onGetWifiList: true,
    onWifiConnected: true,
    setStorageSync: true,
    getStorageSync: true,
    getStorageInfoSync: true,
    removeStorageSync: true,
    clearStorageSync: true,
    getSystemInfoSync: true,
    getExtConfigSync: true,
    getLogManager: true,
    onMemoryWarning: true,
    reportAnalytics: true,
    navigateToSmartGameProgram: true,
    // 文件
    getFileSystemManager: true
};

var noPromiseApis = {
    // 媒体
    stopRecord: true,
    getRecorderManager: true,
    pauseVoice: true,
    stopVoice: true,
    pauseBackgroundAudio: true,
    stopBackgroundAudio: true,
    getBackgroundAudioManager: true,
    createAudioContext: true,
    createInnerAudioContext: true,
    createVideoContext: true,
    createCameraContext: true,
    createLivePlayerContext: true,
    createLivePusherContext: true,
    // 位置
    createMapContext: true,
    // 设备
    canIUse: true,
    startAccelerometer: true,
    stopAccelerometer: true,
    startCompass: true,
    stopCompass: true,
    // 界面
    hideToast: true,
    hideLoading: true,
    showNavigationBarLoading: true,
    hideNavigationBarLoading: true,
    createAnimation: true,
    pageScrollTo: true,
    createSelectorQuery: true,
    createCanvasContext: true,
    createContext: true,
    drawCanvas: true,
    hideKeyboard: true,
    stopPullDownRefresh: true,
    createIntersectionObserver: true,
    onWindowResize: true,
    offWindowResize: true,
    // 拓展接口
    arrayBufferToBase64: true,
    base64ToArrayBuffer: true,
    getAccountInfoSync: true,
    getUpdateManager: true,
    createWorker: true
};

var otherApis = {
    // 网络
    uploadFile: true,
    downloadFile: true,
    connectSocket: true,
    sendSocketMessage: true,
    closeSocket: true,
    // 媒体
    chooseImage: true,
    previewImage: true,
    getImageInfo: true,
    saveImageToPhotosAlbum: true,
    startRecord: true,
    playVoice: true,
    setInnerAudioOption: true,
    getAvailableAudioSources: true,
    getBackgroundAudioPlayerState: true,
    playBackgroundAudio: true,
    seekBackgroundAudio: true,
    chooseVideo: true,
    saveVideoToPhotosAlbum: true,
    loadFontFace: true,
    // 文件
    saveFile: true,
    getFileInfo: true,
    getSavedFileList: true,
    getSavedFileInfo: true,
    removeSavedFile: true,
    openDocument: true,
    // 数据缓存
    setStorage: true,
    getStorage: true,
    getStorageInfo: true,
    removeStorage: true,
    clearStorage: true,
    // 导航
    navigateBack: true,
    navigateTo: true,
    redirectTo: true,
    switchTab: true,
    reLaunch: true,
    // 位置
    getLocation: true,
    chooseLocation: true,
    openLocation: true,
    // 设备
    getSystemInfo: true,
    getNetworkType: true,
    makePhoneCall: true,
    scanCode: true,
    setClipboardData: true,
    getClipboardData: true,
    openBluetoothAdapter: true,
    closeBluetoothAdapter: true,
    getBluetoothAdapterState: true,
    startBluetoothDevicesDiscovery: true,
    stopBluetoothDevicesDiscovery: true,
    getBluetoothDevices: true,
    getConnectedBluetoothDevices: true,
    createBLEConnection: true,
    closeBLEConnection: true,
    getBLEDeviceServices: true,
    getBLEDeviceCharacteristics: true,
    readBLECharacteristicValue: true,
    writeBLECharacteristicValue: true,
    notifyBLECharacteristicValueChange: true,
    startBeaconDiscovery: true,
    stopBeaconDiscovery: true,
    getBeacons: true,
    setScreenBrightness: true,
    getScreenBrightness: true,
    setKeepScreenOn: true,
    vibrateLong: true,
    vibrateShort: true,
    addPhoneContact: true,
    getHCEState: true,
    startHCE: true,
    stopHCE: true,
    sendHCEMessage: true,
    startWifi: true,
    stopWifi: true,
    connectWifi: true,
    getWifiList: true,
    setWifiList: true,
    getConnectedWifi: true,
    // 界面
    showToast: true,
    showLoading: true,
    showModal: true,
    showActionSheet: true,
    setNavigationBarTitle: true,
    setNavigationBarColor: true,
    setTabBarBadge: true,
    removeTabBarBadge: true,
    showTabBarRedDot: true,
    hideTabBarRedDot: true,
    setTabBarStyle: true,
    setTabBarItem: true,
    showTabBar: true,
    hideTabBar: true,
    setTopBarText: true,
    startPullDownRefresh: true,
    canvasToTempFilePath: true,
    canvasGetImageData: true,
    canvasPutImageData: true,
    setBackgroundColor: true,
    setBackgroundTextStyle: true,
    // 第三方平台
    getExtConfig: true,
    // 开放接口
    login: true,
    checkSession: true,
    authorize: true,
    getUserInfo: true,
    checkIsSupportFacialRecognition: true,
    startFacialRecognitionVerify: true,
    startFacialRecognitionVerifyAndUploadVideo: true,
    faceVerifyForPay: true,
    requestPayment: true,
    showShareMenu: true,
    hideShareMenu: true,
    updateShareMenu: true,
    getShareInfo: true,
    chooseAddress: true,
    addCard: true,
    openCard: true,
    openSetting: true,
    getSetting: true,
    getWeRunData: true,
    navigateToMiniProgram: true,
    navigateBackMiniProgram: true,
    chooseInvoice: true,
    chooseInvoiceTitle: true,
    checkIsSupportSoterAuthentication: true,
    startSoterAuthentication: true,
    checkIsSoterEnrolledInDevice: true,
    setEnableDebug: true,
    // 百度小程序专有 API
    // 百度小程序 AI 相关
    ocrIdCard: true,
    ocrBankCard: true,
    ocrDrivingLicense: true,
    ocrVehicleLicense: true,
    textReview: true,
    textToAudio: true,
    imageAudit: true,
    advancedGeneralIdentify: true,
    objectDetectIdentify: true,
    carClassify: true,
    dishClassify: true,
    logoClassify: true,
    animalClassify: true,
    plantClassify: true,
    // 用户信息
    getSwanId: true,
    // 百度收银台支付
    requestPolymerPayment: true,
    // 打开小程序
    navigateToSmartProgram: true,
    navigateBackSmartProgram: true,
    preloadSubPackage: true
};

function initPxTransform(config) {
    var _config$designWidth = config.designWidth, designWidth = _config$designWidth === undefined ? 700 : _config$designWidth, _config$deviceRatio = config.deviceRatio, deviceRatio = _config$deviceRatio === undefined ? {
        640: 1.17,
        750: 1,
        828: .905
    } : _config$deviceRatio;
    this.config = this.config || {};
    this.config.designWidth = designWidth;
    this.config.deviceRatio = deviceRatio;
}

/* eslint-disable camelcase */ var eventCenter = new Events();

var nextTick = function nextTick(fn) {
    var _fn;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
    }
    fn = typeof fn === "function" ? (_fn = fn).bind.apply(_fn, [ null ].concat(args)) : fn;
    var timerFunc = wx.nextTick ? wx.nextTick : setTimeout;
    timerFunc(fn);
};

var commonjsGlobal = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};

function createCommonjsModule(fn, module) {
    return module = {
        exports: {}
    }, fn(module, module.exports), module.exports
    /*
object-assign
(c) Sindre Sorhus
@license MIT
*/
    /* eslint-disable no-unused-vars */;
}

var getOwnPropertySymbols = Object.getOwnPropertySymbols;

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
    if (val === null || val === undefined) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
}

function shouldUseNative() {
    try {
        if (!Object.assign) {
            return false;
        }
        // Detect buggy property enumeration order in older V8 versions.
        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                var test1 = new String("abc");
        // eslint-disable-line no-new-wrappers
                test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
        }
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                var test2 = {};
        for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join("") !== "0123456789") {
            return false;
        }
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
        }
        return true;
    } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
    }
}

var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
            if (hasOwnProperty$1.call(from, key)) {
                to[key] = from[key];
            }
        }
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
                if (propIsEnumerable.call(from, symbols[i])) {
                    to[symbols[i]] = from[symbols[i]];
                }
            }
        }
    }
    return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";

var ReactPropTypesSecret_1 = ReactPropTypesSecret;

var printWarning = function printWarning() {};

{
    var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
    var loggedTypeFailures = {};
    printWarning = function printWarning(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    {
        for (var typeSpecName in typeSpecs) {
            if (typeSpecs.hasOwnProperty(typeSpecName)) {
                var error;
                // Prop type validation may throw. In case they do, we don't want to
                // fail the render phase where it didn't fail before. So we log it.
                // After these have been cleaned up, we'll let them throw.
                                try {
                    // This is intentionally an invariant that gets caught. It's the same
                    // behavior as without this statement except with a better message.
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                        var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + _typeof(typeSpecs[typeSpecName]) + "`.");
                        err.name = "Invariant Violation";
                        throw err;
                    }
                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
                } catch (ex) {
                    error = ex;
                }
                if (error && !(error instanceof Error)) {
                    printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker " + "function must return `null` or an `Error` but returned a " + _typeof(error) + ". " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).");
                }
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    // Only monitor this failure once because there tends to be a lot of the
                    // same error.
                    loggedTypeFailures[error.message] = true;
                    var stack = getStack ? getStack() : "";
                    printWarning("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
                }
            }
        }
    }
}

var checkPropTypes_1 = checkPropTypes;

var printWarning$1 = function printWarning() {};

{
    printWarning$1 = function printWarning(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };
}

function emptyFunctionThatReturnsNull() {
    return null;
}

var factoryWithTypeCheckers = function factoryWithTypeCheckers(isValidElement, throwOnDirectAccess) {
    /* global Symbol */
    var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    // Before Symbol spec.
    /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */    function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
            return iteratorFn;
        }
    }
    /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */    var ANONYMOUS = "<<anonymous>>";
    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
        var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
    };
    /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
    /*eslint-disable no-self-compare*/    function is(x, y) {
        // SameValue algorithm
        if (x === y) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return x !== 0 || 1 / x === 1 / y;
        } else {
            // Step 6.a: NaN == NaN
            return x !== x && y !== y;
        }
    }
    /*eslint-enable no-self-compare*/
    /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */    function PropTypeError(message) {
        this.message = message;
        this.stack = "";
    }
    // Make `instanceof Error` still work for returned errors.
        PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
        {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret_1) {
                if (throwOnDirectAccess) {
                    // New behavior only for users of `prop-types` package
                    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
                    err.name = "Invariant Violation";
                    throw err;
                } else if (typeof console !== "undefined") {
                    // Old behavior for people using React.PropTypes
                    var cacheKey = componentName + ":" + propName;
                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                    manualPropTypeWarningCount < 3) {
                        printWarning$1("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated " + "and will throw in the standalone `prop-types` package. " + "You may be seeing this warning due to a third-party PropTypes " + "library. See https://fb.me/react-warning-dont-call-proptypes " + "for details.");
                        manualPropTypeCallCache[cacheKey] = true;
                        manualPropTypeWarningCount++;
                    }
                }
            }
            if (props[propName] == null) {
                if (isRequired) {
                    if (props[propName] === null) {
                        return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                    }
                    return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
                }
                return null;
            } else {
                return validate(props, propName, componentName, location, propFullName);
            }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
                return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i = 0; i < propValue.length; i++) {
                var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret_1);
                if (error instanceof Error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
            printWarning$1("Invalid argument supplied to oneOf, expected an instance of array.");
            return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for (var i = 0; i < expectedValues.length; i++) {
                if (is(propValue, expectedValues[i])) {
                    return null;
                }
            }
            var valuesString = JSON.stringify(expectedValues);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + propValue + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
                return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
                if (propValue.hasOwnProperty(key)) {
                    var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret_1);
                    if (error instanceof Error) {
                        return error;
                    }
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
            printWarning$1("Invalid argument supplied to oneOfType, expected an instance of array.");
            return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== "function") {
                printWarning$1("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
                return emptyFunctionThatReturnsNull;
            }
        }
        function validate(props, propName, componentName, location, propFullName) {
            for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                var checker = arrayOfTypeCheckers[i];
                if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
                    return null;
                }
            }
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`."));
        }
        return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
                var checker = shapeTypes[key];
                if (!checker) {
                    continue;
                }
                var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret_1);
                if (error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            // We need to check all keys in case some are required but missing from
            // props.
                        var allKeys = objectAssign({}, props[propName], shapeTypes);
            for (var key in allKeys) {
                var checker = shapeTypes[key];
                if (!checker) {
                    return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`." + "\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
                }
                var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret_1);
                if (error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
        switch (_typeof(propValue)) {
          case "number":
          case "string":
          case "undefined":
            return true;

          case "boolean":
            return !propValue;

          case "object":
            if (Array.isArray(propValue)) {
                return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
                return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                    while (!(step = iterator.next()).done) {
                        if (!isNode(step.value)) {
                            return false;
                        }
                    }
                } else {
                    // Iterator will provide entry [k,v] tuples rather than values.
                    while (!(step = iterator.next()).done) {
                        var entry = step.value;
                        if (entry) {
                            if (!isNode(entry[1])) {
                                return false;
                            }
                        }
                    }
                }
            } else {
                return false;
            }
            return true;

          default:
            return false;
        }
    }
    function isSymbol(propType, propValue) {
        // Native Symbol.
        if (propType === "symbol") {
            return true;
        }
        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
                if (propValue["@@toStringTag"] === "Symbol") {
            return true;
        }
        // Fallback for non-spec compliant Symbols which are polyfilled.
                if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
        }
        return false;
    }
    // Equivalent of `typeof` but with special handling for array and regexp.
        function getPropType(propValue) {
        var propType = _typeof(propValue);
        if (Array.isArray(propValue)) {
            return "array";
        }
        if (propValue instanceof RegExp) {
            // Old webkits (at least until Android 4.0) return 'function' rather than
            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
            // passes PropTypes.object.
            return "object";
        }
        if (isSymbol(propType, propValue)) {
            return "symbol";
        }
        return propType;
    }
    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
        function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
            if (propValue instanceof Date) {
                return "date";
            } else if (propValue instanceof RegExp) {
                return "regexp";
            }
        }
        return propType;
    }
    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
        function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;

          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;

          default:
            return type;
        }
    }
    // Returns class name of the object, if any.
        function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
        }
        return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes_1;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
};

function emptyFunction() {}

var factoryWithThrowingShims = function factoryWithThrowingShims() {
    function shim(props, propName, componentName, location, propFullName, secret) {
        if (secret === ReactPropTypesSecret_1) {
            // It is still safe when called from React.
            return;
        }
        var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
        err.name = "Invariant Violation";
        throw err;
    }
    shim.isRequired = shim;
    function getShim() {
        return shim;
    }
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
        var ReactPropTypes = {
        array: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim
    };
    ReactPropTypes.checkPropTypes = emptyFunction;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
};

var propTypes = createCommonjsModule(function(module) {
    /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
    {
        var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 60103;
        var isValidElement = function isValidElement(object) {
            return _typeof(object) === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        };
        // By explicitly using `prop-types` you are opting into new development behavior.
        // http://fb.me/prop-types-in-prod
                var throwOnDirectAccess = true;
        module.exports = factoryWithTypeCheckers(isValidElement, throwOnDirectAccess);
    }
});

/* eslint-disable */ Object.is = Object.is || function(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    }
    return x !== x && y !== y;
};

function shallowEqual(obj1, obj2) {
    if (obj1 === null && obj2 === null) {
        return true;
    }
    if (obj1 === null || obj2 === null) {
        return false;
    }
    if (Object.is(obj1, obj2)) {
        return true;
    }
    var obj1Keys = obj1 ? Object.keys(obj1) : [];
    var obj2Keys = obj2 ? Object.keys(obj2) : [];
    if (obj1Keys.length !== obj2Keys.length) {
        return false;
    }
    for (var i = 0; i < obj1Keys.length; i++) {
        var obj1KeyItem = obj1Keys[i];
        if (!obj2.hasOwnProperty(obj1KeyItem) || !Object.is(obj1[obj1KeyItem], obj2[obj1KeyItem])) {
            return false;
        }
    }
    return true;
}

function addLeadingSlash(path) {
    return path.charAt(0) === "/" ? path : "/" + path;
}

function getCurrentPageUrl() {
    var pages = getCurrentPages();
    var currentPage = pages[pages.length - 1];
    return addLeadingSlash(currentPage.route || currentPage.__route__);
}

/** Detect free variable `global` from Node.js. */ var freeGlobal$1 = _typeof(commonjsGlobal) == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal$1;

/** Detect free variable `self`. */ var freeSelf$1 = (typeof self === "undefined" ? "undefined" : _typeof(self)) == "object" && self && self.Object === Object && self;

/** Used as a reference to the global object. */ var root$1 = _freeGlobal || freeSelf$1 || Function("return this")();

var _root = root$1;

/** Built-in value references. */ var _Symbol2 = _root.Symbol;

var _Symbol$1 = _Symbol2;

/** Used for built-in method references. */ var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */ var hasOwnProperty$2 = objectProto$1.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto$1.toString;

/** Built-in value references. */ var symToStringTag = _Symbol$1 ? _Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty$2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    {
        if (isOwn) {
            value[symToStringTag] = tag;
        } else {
            delete value[symToStringTag];
        }
    }
    return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */ var objectProto$2 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString$1 = objectProto$2.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString$1(value) {
    return nativeObjectToString$1.call(value);
}

var _objectToString = objectToString$1;

/** `Object#toString` result references. */ var nullTag = "[object Null]", undefinedTag = "[object Undefined]";

/** Built-in value references. */ var symToStringTag$1 = _Symbol$1 ? _Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}

var _overArg = overArg;

/** Built-in value references. */ var getPrototype = _overArg(Object.getPrototypeOf, Object);

var _getPrototype = getPrototype;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike$1(value) {
    return value != null && _typeof(value) == "object";
}

var isObjectLike_1 = isObjectLike$1;

/** `Object#toString` result references. */ var objectTag = "[object Object]";

/** Used for built-in method references. */ var funcProto$1 = Function.prototype, objectProto$3 = Object.prototype;

/** Used to resolve the decompiled source of functions. */ var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */ var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/** Used to infer the `Object` constructor. */ var objectCtorString = funcToString$1.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */ function isPlainObject(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag) {
        return false;
    }
    var proto = _getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$1.call(Ctor) == objectCtorString;
}

var isPlainObject_1 = isPlainObject;

function isEmptyObject(obj) {
    if (!obj || !isPlainObject_1(obj)) {
        return false;
    }
    for (var n in obj) {
        if (obj.hasOwnProperty(n)) {
            return false;
        }
    }
    return true;
}

function noop() {}

function isFunction$1(arg) {
    return typeof arg === "function";
}

function isArray$1(arg) {
    return Array.isArray(arg);
}

function shakeFnFromObject(obj) {
    var newObj;
    if (isArray$1(obj)) {
        newObj = [];
        var len = obj.length;
        for (var i = 0; i < len; i++) {
            newObj.push(shakeFnFromObject(obj[i]));
        }
    } else if (isPlainObject_1(obj)) {
        newObj = {};
        for (var key in obj) {
            if (isFunction$1(obj[key])) {
                continue;
            }
            var ret = shakeFnFromObject(obj[key]);
            newObj[key] = ret;
        }
    } else {
        return obj;
    }
    return newObj;
}

var keyList = Object.keys;

var hasProp = Object.prototype.hasOwnProperty;

function diffArrToPath(to, from) {
    var res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var keyPrev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
    var len = to.length;
    var _loop = function _loop(i) {
        var toItem = to[i];
        var fromItem = from[i];
        var targetKey = "".concat(keyPrev, "[").concat(i, "]");
        if (toItem === fromItem) {
            return "continue";
        } else if (_typeof(toItem) !== _typeof(fromItem)) {
            res[targetKey] = toItem;
        } else {
            if (_typeof(toItem) !== "object") {
                res[targetKey] = toItem;
            } else {
                var arrTo = isArray$1(toItem);
                var arrFrom = isArray$1(fromItem);
                if (arrTo !== arrFrom) {
                    res[targetKey] = toItem;
                } else if (arrTo && arrFrom) {
                    if (toItem.length === fromItem.length) {
                        diffArrToPath(toItem, fromItem, res, "".concat(targetKey));
                    } else {
                        res[targetKey] = toItem;
                    }
                } else {
                    if (!toItem || !fromItem || keyList(toItem).length < keyList(fromItem).length) {
                        res[targetKey] = toItem;
                    } else {
                        // 对象
                        var shouldDiffObject = true;
                        Object.keys(fromItem).some(function(key) {
                            if (typeof toItem[key] === "undefined") {
                                shouldDiffObject = false;
                                return true;
                            }
                        });
                        if (shouldDiffObject) {
                            diffObjToPath(toItem, fromItem, res, "".concat(targetKey, "."));
                        } else {
                            res[targetKey] = toItem;
                        }
                    }
                }
            }
        }
    };
    for (var i = 0; i < len; i++) {
        var _ret = _loop(i);
        if (_ret === "continue") continue;
    }
    return res;
}

// 比较的对象均为plainObject，且函数已被过滤
function diffObjToPath(to, from) {
    var res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var keyPrev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
    var keys = keyList(to);
    var len = keys.length;
    var _loop2 = function _loop2(i) {
        var key = keys[i];
        var toItem = to[key];
        var fromItem = from[key];
        var targetKey = "".concat(keyPrev).concat(key);
        if (toItem === fromItem) {
            return "continue";
        } else if (!hasProp.call(from, key)) {
            res[targetKey] = toItem;
        } else if (_typeof(toItem) !== _typeof(fromItem)) {
            res[targetKey] = toItem;
        } else {
            if (_typeof(toItem) !== "object") {
                res[targetKey] = toItem;
            } else {
                var arrTo = isArray$1(toItem);
                var arrFrom = isArray$1(fromItem);
                if (arrTo !== arrFrom) {
                    res[targetKey] = toItem;
                } else if (arrTo && arrFrom) {
                    if (toItem.length === fromItem.length) {
                        diffArrToPath(toItem, fromItem, res, "".concat(targetKey));
                    } else {
                        res[targetKey] = toItem;
                    }
                } else {
                    // null
                    if (!toItem || !fromItem) {
                        res[targetKey] = toItem;
                    } else {
                        // 对象
                        var shouldDiffObject = true;
                        Object.keys(fromItem).some(function(key) {
                            if (typeof toItem[key] === "undefined") {
                                shouldDiffObject = false;
                                return true;
                            }
                        });
                        if (shouldDiffObject) {
                            diffObjToPath(toItem, fromItem, res, "".concat(targetKey, "."));
                        } else {
                            res[targetKey] = toItem;
                        }
                    }
                }
            }
        }
    };
    for (var i = 0; i < len; i++) {
        var _ret2 = _loop2(i);
        if (_ret2 === "continue") continue;
    }
    return res;
}

function queryToJson(str) {
    var dec = decodeURIComponent;
    var qp = str.split("&");
    var ret = {};
    var name;
    var val;
    for (var i = 0, l = qp.length, item; i < l; ++i) {
        item = qp[i];
        if (item.length) {
            var s = item.indexOf("=");
            if (s < 0) {
                name = dec(item);
                val = "";
            } else {
                name = dec(item.slice(0, s));
                val = dec(item.slice(s + 1));
            }
            if (typeof ret[name] === "string") {
                // inline'd type check
                ret[name] = [ ret[name] ];
            }
            if (isArray$1(ret[name])) {
                ret[name].push(val);
            } else {
                ret[name] = val;
            }
        }
    }
    return ret;
    // Object
}

var _loadTime = new Date().getTime().toString();

var _i = 1;

function getUniqueKey() {
    return _loadTime + _i++;
}

function getElementById(component, id, type) {
    if (!component) return null;
    var res;
    if (type === "component") {
        res = component.selectComponent(id);
        res = res ? res.$component || res : null;
    } else {
        var query = wx.createSelectorQuery().in(component);
        res = query.select(id);
    }
    if (res) return res;
    return null;
}

var data = {};

function cacheDataSet(key, val) {
    data[key] = val;
}

function cacheDataGet(key, delelteAfterGet) {
    var temp = data[key];
    delelteAfterGet && delete data[key];
    return temp;
}

function cacheDataHas(key) {
    return key in data;
}

var privatePropValName = "__triggerObserer";

var anonymousFnNamePreffix = "funPrivate";

var componentFnReg = /^__fn_/;

var routerParamsPrivateKey = "__key_";

var preloadPrivateKey = "__preload_";

var PRELOAD_DATA_KEY = "preload";

var preloadInitedComponent = "$preloadComponent";

var pageExtraFns = [ "onPullDownRefresh", "onReachBottom", "onShareAppMessage", "onPageScroll", "onTabItemTap", "onResize" ];

function bindProperties(weappComponentConf, ComponentClass, isPage) {
    weappComponentConf.properties = ComponentClass.properties || {};
    var defaultProps = ComponentClass.defaultProps || {};
    for (var key in defaultProps) {
        if (defaultProps.hasOwnProperty(key)) {
            weappComponentConf.properties[key] = {
                type: null,
                value: null
            };
        }
    }
    if (isPage) {
        weappComponentConf.properties[routerParamsPrivateKey] = {
            type: null,
            value: null
        };
        weappComponentConf.properties[preloadPrivateKey] = {
            type: null,
            value: null
        };
        var defaultParams = ComponentClass.defaultParams || {};
        for (var _key in defaultParams) {
            if (defaultParams.hasOwnProperty(_key)) {
                weappComponentConf.properties[_key] = {
                    type: null,
                    value: null
                };
            }
        }
    }
    // 拦截props的更新，插入生命周期
    // 调用小程序setData或会造成性能消耗
        weappComponentConf.properties[privatePropValName] = {
        type: null,
        observer: function observer() {
            if (!this.$component || !this.$component.__isReady) return;
            var nextProps = filterProps(ComponentClass.properties, ComponentClass.defaultProps, this.$component.props, this.data);
            this.$component.props = nextProps;
            this.$component._unsafeCallUpdate = true;
            updateComponent(this.$component);
            this.$component._unsafeCallUpdate = false;
        }
    };
}

function bindBehaviors(weappComponentConf, ComponentClass) {
    if (ComponentClass.behaviors) {
        weappComponentConf.behaviors = ComponentClass.behaviors;
    }
}

function bindStaticOptions(weappComponentConf, ComponentClass) {
    if (ComponentClass.options) {
        weappComponentConf.options = ComponentClass.options;
    }
}

function bindMultipleSlots(weappComponentConf, ComponentClass) {
    var multipleSlots = ComponentClass.multipleSlots;
    if (!multipleSlots) {
        return;
    }
    weappComponentConf.options = _objectSpread({}, weappComponentConf.options, {
        multipleSlots: multipleSlots
    });
}

function bindStaticFns(weappComponentConf, ComponentClass) {
    for (var key in ComponentClass) {
        typeof ComponentClass[key] === "function" && (weappComponentConf[key] = ComponentClass[key]);
    }
    // 低版本 IOS 下部分属性不能直接访问
        Object.getOwnPropertyNames(ComponentClass).forEach(function(key) {
        var excludes = [ "arguments", "caller", "length", "name", "prototype" ];
        if (excludes.indexOf(key) < 0) {
            typeof ComponentClass[key] === "function" && (weappComponentConf[key] = ComponentClass[key]);
        }
    });
}

function processEvent(eventHandlerName, obj) {
    if (obj[eventHandlerName]) return;
    obj[eventHandlerName] = function(event) {
        if (event) {
            event.preventDefault = function() {};
            event.stopPropagation = function() {};
            event.currentTarget = event.currentTarget || event.target || {};
            if (event.target) {
                Object.assign(event.target, event.detail);
            }
            Object.assign(event.currentTarget, event.detail);
        }
        var scope = this.$component;
        var callScope = scope;
        var isAnonymousFn = eventHandlerName.indexOf(anonymousFnNamePreffix) > -1;
        var realArgs = [];
        var detailArgs = [];
        var datasetArgs = [];
        var isScopeBinded = false;
        // 解析从dataset中传过来的参数
                var dataset = event.currentTarget.dataset || {};
        var bindArgs = {};
        var eventType = event.type.toLocaleLowerCase();
        Object.keys(dataset).forEach(function(key) {
            var keyLower = key.toLocaleLowerCase();
            if (/^e/.test(keyLower)) {
                // 小程序属性里中划线后跟一个下划线会解析成不同的结果
                keyLower = keyLower.replace(/^e/, "");
                keyLower = keyLower.toLocaleLowerCase();
                if (keyLower.indexOf(eventType) >= 0) {
                    var argName = keyLower.replace(eventType, "");
                    bindArgs[argName] = dataset[key];
                }
            }
        });
        // 如果是通过triggerEvent触发,并且带有参数
                if (event.detail && event.detail.__arguments && event.detail.__arguments.length > 0) {
            detailArgs = event.detail.__arguments;
        }
        // 普通的事件（非匿名函数），会直接call
                if (!isAnonymousFn) {
            if ("so" in bindArgs) {
                if (bindArgs["so"] !== "this") {
                    callScope = bindArgs["so"];
                }
                isScopeBinded = true;
                delete bindArgs["so"];
            }
            if (detailArgs.length > 0) {
                !isScopeBinded && detailArgs[0] && (callScope = detailArgs[0]);
                detailArgs.shift();
            }
            if (!isEmptyObject(bindArgs)) {
                datasetArgs = Object.keys(bindArgs).sort().map(function(key) {
                    return bindArgs[key];
                });
            }
            realArgs = _toConsumableArray(datasetArgs).concat(_toConsumableArray(detailArgs), [ event ]);
        } else {
            // 匿名函数，会将scope作为第一个参数
            var _scope = null;
            if ("so" in bindArgs) {
                if (bindArgs["so"] !== "this") {
                    _scope = bindArgs["so"];
                }
                isScopeBinded = true;
                delete bindArgs["so"];
            }
            if (detailArgs.length > 0) {
                !isScopeBinded && detailArgs[0] && (callScope = detailArgs[0]);
                detailArgs.shift();
            }
            if (!isEmptyObject(bindArgs)) {
                datasetArgs = Object.keys(bindArgs).sort().map(function(key) {
                    return bindArgs[key];
                });
            }
            realArgs = [ _scope ].concat(_toConsumableArray(datasetArgs), _toConsumableArray(detailArgs), [ event ]);
        }
        return scope[eventHandlerName].apply(callScope, realArgs);
    };
}

function bindEvents(weappComponentConf, events, isPage) {
    weappComponentConf.methods = weappComponentConf.methods || {};
    var target = weappComponentConf.methods;
    events.forEach(function(name) {
        processEvent(name, target);
    });
}

function filterProps(properties) {
    var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var componentProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var weappComponentData = arguments.length > 3 ? arguments[3] : undefined;
    var newProps = Object.assign({}, componentProps);
    for (var propName in properties) {
        if (propName === privatePropValName) {
            continue;
        }
        if (typeof componentProps[propName] === "function") {
            newProps[propName] = componentProps[propName];
        } else if (propName in weappComponentData) {
            newProps[propName] = weappComponentData[propName];
        }
        if (componentFnReg.test(propName)) {
            if (weappComponentData[propName] === true) {
                var fnName = propName.replace(componentFnReg, "");
                newProps[fnName] = noop;
            }
            delete newProps[propName];
        }
    }
    if (!isEmptyObject(defaultProps)) {
        for (var _propName in defaultProps) {
            if (newProps[_propName] === undefined || newProps[_propName] === null) {
                newProps[_propName] = defaultProps[_propName];
            }
        }
    }
    return newProps;
}

function filterParams(data) {
    var defaultParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var res = {};
    for (var paramName in defaultParams) {
        res[paramName] = paramName in data ? data[paramName] : defaultParams[paramName];
    }
    return res;
}

function componentTrigger(component, key, args) {
    var _component$key;
    args = args || [];
    if (key === "componentDidMount") {
        if (component["$$refs"] && component["$$refs"].length > 0) {
            var refs = {};
            component["$$refs"].forEach(function(ref) {
                var target;
                if (ref.type === "component") {
                    target = component.$scope.selectComponent("#".concat(ref.id));
                    target = target ? target.$component || target : null;
                } else {
                    var query = wx.createSelectorQuery().in(component.$scope);
                    target = query.select("#".concat(ref.id));
                }
                if ("refName" in ref && ref["refName"]) {
                    refs[ref.refName] = target;
                } else if ("fn" in ref && typeof ref["fn"] === "function") {
                    ref["fn"].call(component, target);
                }
                ref.target = target;
            });
            component.refs = Object.assign({}, component.refs || {}, refs);
        }
    }
    if (key === "componentWillUnmount") {
        component._dirty = true;
        component._disable = true;
        component.$router = {
            params: {},
            path: ""
        };
        component._pendingStates = [];
        component._pendingCallbacks = [];
    }
    component[key] && typeof component[key] === "function" && (_component$key = component[key]).call.apply(_component$key, [ component ].concat(_toConsumableArray(args)));
    if (key === "componentWillMount") {
        component._dirty = false;
        component._disable = false;
        component.state = component.getState();
    }
    if (key === "componentWillUnmount") {
        // refs
        if (component["$$refs"] && component["$$refs"].length > 0) {
            component["$$refs"].forEach(function(ref) {
                return typeof ref["fn"] === "function" && ref["fn"].call(component, null);
            });
            component.refs = {};
        }
    }
}

function initComponent(ComponentClass, isPage) {
    if (this.$component.__isReady) return;
    // ready之后才可以setData,
    // ready之前，小程序组件初始化时仍然会触发observer，__isReady为否的时候放弃处理observer
        this.$component.__isReady = true;
    // 页面Ready的时候setData更新，此时并未didMount,触发observer但不会触发子组件更新
    // 小程序组件ready，但是数据并没有ready，需要通过updateComponent来初始化数据，setData完成之后才是真正意义上的组件ready
    // 动态组件执行改造函数副本的时,在初始化数据前计算好props
        if (!isPage) {
        var nextProps = filterProps(ComponentClass.properties, ComponentClass.defaultProps, this.$component.props, this.data);
        this.$component.props = nextProps;
    }
    updateComponent(this.$component);
}

function createComponent(ComponentClass, isPage) {
    var initData = {
        _componentProps: 1
    };
    var componentProps = filterProps({}, ComponentClass.defaultProps);
    var componentInstance = new ComponentClass(componentProps);
    componentInstance._constructor && componentInstance._constructor(componentProps);
    try {
        componentInstance.state = componentInstance._createData() || componentInstance.state;
    } catch (err) {
        if (isPage) {
            console.warn("[Taro warn] 请给页面提供初始 `state` 以提高初次渲染性能！");
        } else {
            console.warn("[Taro warn] 请给组件提供一个 `defaultProps` 以提高初次渲染性能！");
        }
        console.warn(err);
    }
    initData = Object.assign({}, initData, componentInstance.props, componentInstance.state);
    var weappComponentConf = {
        data: initData,
        created: function created() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            if (isPage && cacheDataHas(preloadInitedComponent)) {
                this.$component = cacheDataGet(preloadInitedComponent, true);
            } else {
                this.$component = new ComponentClass({}, isPage);
            }
            this.$component._init(this);
            this.$component.render = this.$component._createData;
            this.$component.__propTypes = ComponentClass.propTypes;
            Object.assign(this.$component.$router.params, options);
        },
        attached: function attached() {
            var hasParamsCache;
            if (isPage) {
                // params
                var params = {};
                hasParamsCache = cacheDataHas(this.data[routerParamsPrivateKey]);
                if (hasParamsCache) {
                    params = Object.assign({}, ComponentClass.defaultParams, cacheDataGet(this.data[routerParamsPrivateKey], true));
                } else {
                    // 直接启动，非内部跳转
                    params = filterParams(this.data, ComponentClass.defaultParams);
                }
                if (cacheDataHas(PRELOAD_DATA_KEY)) {
                    var data = cacheDataGet(PRELOAD_DATA_KEY, true);
                    this.$component.$router.preload = data;
                }
                Object.assign(this.$component.$router.params, params);
                // preload
                                if (cacheDataHas(this.data[preloadPrivateKey])) {
                    this.$component.$preloadData = cacheDataGet(this.data[preloadPrivateKey], true);
                } else {
                    this.$component.$preloadData = null;
                }
            }
            if (!isPage || hasParamsCache || ComponentClass.defaultParams) {
                initComponent.apply(this, [ ComponentClass, isPage ]);
            }
        },
        ready: function ready() {
            if (!isPage && !this.$component.__mounted) {
                this.$component.__mounted = true;
                componentTrigger(this.$component, "componentDidMount");
            }
        },
        detached: function detached() {
            componentTrigger(this.$component, "componentWillUnmount");
        }
    };
    if (isPage) {
        weappComponentConf.methods = weappComponentConf.methods || {};
        weappComponentConf.methods["onLoad"] = function() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            if (this.$component.__isReady) return;
            Object.assign(this.$component.$router.params, options);
            this.$component.$router.path = getCurrentPageUrl();
            initComponent.apply(this, [ ComponentClass, isPage ]);
        };
        weappComponentConf.methods["onReady"] = function() {
            this.$component.__mounted = true;
            componentTrigger(this.$component, "componentDidMount");
        };
        weappComponentConf.methods["onShow"] = function() {
            componentTrigger(this.$component, "componentDidShow");
        };
        weappComponentConf.methods["onHide"] = function() {
            componentTrigger(this.$component, "componentDidHide");
        };
        pageExtraFns.forEach(function(fn) {
            if (componentInstance[fn] && typeof componentInstance[fn] === "function") {
                weappComponentConf.methods[fn] = function() {
                    var component = this.$component;
                    if (component[fn] && typeof component[fn] === "function") {
                        var _component$fn;
                        return (_component$fn = component[fn]).call.apply(_component$fn, [ component ].concat(Array.prototype.slice.call(arguments)));
                    }
                };
            }
        });
        __wxRoute && cacheDataSet(__wxRoute, ComponentClass);
    } else {
        weappComponentConf.pageLifetimes = weappComponentConf.pageLifetimes || {};
        weappComponentConf.pageLifetimes["show"] = function() {
            componentTrigger(this.$component, "componentDidShow");
        };
        weappComponentConf.pageLifetimes["hide"] = function() {
            componentTrigger(this.$component, "componentDidHide");
        };
        weappComponentConf.pageLifetimes["resize"] = function() {
            componentTrigger(this.$component, "onResize");
        };
    }
    bindProperties(weappComponentConf, ComponentClass, isPage);
    bindBehaviors(weappComponentConf, ComponentClass);
    bindStaticFns(weappComponentConf, ComponentClass);
    bindStaticOptions(weappComponentConf, ComponentClass);
    bindMultipleSlots(weappComponentConf, ComponentClass);
    ComponentClass["$$events"] && bindEvents(weappComponentConf, ComponentClass["$$events"], isPage);
    if (ComponentClass["externalClasses"] && ComponentClass["externalClasses"].length) {
        weappComponentConf["externalClasses"] = ComponentClass["externalClasses"];
    }
    return weappComponentConf;
}

var isDEV = typeof process === "undefined" || !process.env || true;

var privatePropKeyName = "_triggerObserer";

function updateComponent(component) {
    var props = component.props, __propTypes = component.__propTypes;
    if (isDEV && __propTypes) {
        var componentName = component.constructor.name || component.constructor.toString().match(/^function\s*([^\s(]+)/)[1];
        propTypes.checkPropTypes(__propTypes, props, "prop", componentName);
    }
    var prevProps = component.prevProps || props;
    component.props = prevProps;
    if (component.__mounted && component._unsafeCallUpdate === true && component.componentWillReceiveProps) {
        component._disable = true;
        component.componentWillReceiveProps(props);
        component._disable = false;
    }
    // 在willMount前执行构造函数的副本
        if (!component.__componentWillMountTriggered) {
        component._constructor && component._constructor(props);
    }
    var state = component.getState();
    var prevState = component.prevState || state;
    var skip = false;
    if (component.__mounted) {
        if (typeof component.shouldComponentUpdate === "function" && !component._isForceUpdate && component.shouldComponentUpdate(props, state) === false) {
            skip = true;
        } else if (typeof component.componentWillUpdate === "function") {
            component.componentWillUpdate(props, state);
        }
    }
    component.props = props;
    component.state = state;
    component._dirty = false;
    component._isForceUpdate = false;
    if (!component.__componentWillMountTriggered) {
        component.__componentWillMountTriggered = true;
        componentTrigger(component, "componentWillMount");
    }
    if (!skip) {
        doUpdate(component, prevProps, prevState);
    }
    component.prevProps = component.props;
    component.prevState = component.state;
}

function doUpdate(component, prevProps, prevState) {
    var state = component.state, _component$props = component.props, props = _component$props === undefined ? {} : _component$props;
    var data = state || {};
    if (component._createData) {
        // 返回null或undefined则保持不变
        data = component._createData(state, props) || data;
    }
    var privatePropKeyVal = component.$scope.data[privatePropKeyName] || false;
    data = Object.assign({}, props, data);
    if (component.$usedState && component.$usedState.length) {
        var _data = {};
        component.$usedState.forEach(function(key) {
            var val = get(data, key);
            if (typeof val === "undefined") {
                return;
            }
            if (_typeof(val) === "object") {
                if (isEmptyObject(val)) return set$1(_data, key, val);
                val = shakeFnFromObject(val);
                // 避免筛选完 Fn 后产生了空对象还去渲染
                                if (!isEmptyObject(val)) set$1(_data, key, val);
            } else {
                set$1(_data, key, val);
            }
        });
        data = _data;
    }
    // 改变这个私有的props用来触发(observer)子组件的更新
        data[privatePropKeyName] = !privatePropKeyVal;
    var dataDiff = diffObjToPath(data, component.$scope.data);
    var __mounted = component.__mounted;
    // 每次 setData 都独立生成一个 callback 数组
        var cbs = [];
    if (component._pendingCallbacks && component._pendingCallbacks.length) {
        cbs = component._pendingCallbacks;
        component._pendingCallbacks = [];
    }
    component.$scope.setData(dataDiff, function() {
        if (__mounted) {
            if (component["$$refs"] && component["$$refs"].length > 0) {
                component["$$refs"].forEach(function(ref) {
                    // 只有 component 类型能做判断。因为 querySelector 每次调用都一定返回 nodeRefs，无法得知 dom 类型的挂载状态。
                    if (ref.type !== "component") return;
                    var target = component.$scope.selectComponent("#".concat(ref.id));
                    target = target ? target.$component || target : null;
                    var prevRef = ref.target;
                    if (target !== prevRef) {
                        if (ref.refName) component.refs[ref.refName] = target;
                        typeof ref.fn === "function" && ref.fn.call(component, target);
                        ref.target = target;
                    }
                });
            }
            if (typeof component.componentDidUpdate === "function") {
                component.componentDidUpdate(prevProps, prevState);
            }
        }
        if (cbs.length) {
            var i = cbs.length;
            while (--i >= 0) {
                typeof cbs[i] === "function" && cbs[i].call(component);
            }
        }
    });
}

var items = [];

function enqueueRender(component) {
    // tslint:disable-next-line:no-conditional-assignment
    if (!component._dirty && (component._dirty = true) && items.push(component) === 1) {
        nextTick(rerender);
    }
}

function rerender() {
    var p;
    var list = items;
    items = [];
    // tslint:disable-next-line:no-conditional-assignment
        while (p = list.pop()) {
        if (p._dirty) {
            updateComponent(p, true);
        }
    }
}

// #私有的__componentProps更新用于触发子组件中对应obsever，生命周期componentWillReceiveProps,componentShouldUpdate在这里处理
// #父组件传过来的props放到data.__props中供模板使用，这么做的目的是模拟receiveProps生命周期
// 执行顺序：组件setState -> 组件_createData() -> 对应的小程序组件setData（组件更新）-> 子组件的__componentProps.observer执行
//          -> 触发子组件componentWillReceiveProps，更新子组件props,componentShouldUpdate -> 子组件_createData -> 子组件setData
var PRELOAD_DATA_KEY$1 = "preload";

var BaseComponent = 
/* */
function() {
    // _createData的时候生成，小程序中通过data.__createData访问
    // this.props,小程序中通过data.__props访问
    // 会在componentDidMount后置为true
    function BaseComponent() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var isPage = arguments.length > 1 ? arguments[1] : undefined;
        _classCallCheck(this, BaseComponent);
        _defineProperty(this, "__computed", {});
        _defineProperty(this, "__props", {});
        _defineProperty(this, "__isReady", false);
        _defineProperty(this, "__mounted", false);
        _defineProperty(this, "nextProps", {});
        _defineProperty(this, "_dirty", true);
        _defineProperty(this, "_disable", true);
        _defineProperty(this, "_isForceUpdate", false);
        _defineProperty(this, "_pendingStates", []);
        _defineProperty(this, "_pendingCallbacks", []);
        _defineProperty(this, "$componentType", "");
        _defineProperty(this, "$router", {
            params: {},
            path: ""
        });
        this.state = {};
        this.props = props;
        this.$componentType = isPage ? "PAGE" : "COMPONENT";
    }
    _createClass(BaseComponent, [ {
        key: "_constructor",
        value: function _constructor(props) {
            this.props = props || {};
        }
    }, {
        key: "_init",
        value: function _init(scope) {
            this.$scope = scope;
        }
    }, {
        key: "setState",
        value: function setState(state, callback) {
            if (state) {
                (this._pendingStates = this._pendingStates || []).push(state);
            }
            if (isFunction$1(callback)) {
                (this._pendingCallbacks = this._pendingCallbacks || []).push(callback);
            }
            if (!this._disable) {
                enqueueRender(this);
            }
        }
    }, {
        key: "getState",
        value: function getState() {
            var _this = this;
            var _pendingStates = this._pendingStates, state = this.state, props = this.props;
            var stateClone = Object.assign({}, state);
            delete stateClone.__data;
            if (!_pendingStates.length) {
                return stateClone;
            }
            var queue = _pendingStates.concat();
            this._pendingStates.length = 0;
            queue.forEach(function(nextState) {
                if (isFunction$1(nextState)) {
                    nextState = nextState.call(_this, stateClone, props);
                }
                Object.assign(stateClone, nextState);
            });
            return stateClone;
        }
    }, {
        key: "forceUpdate",
        value: function forceUpdate(callback) {
            if (isFunction$1(callback)) {
                (this._pendingCallbacks = this._pendingCallbacks || []).push(callback);
            }
            this._isForceUpdate = true;
            updateComponent(this);
        }
    }, {
        key: "$preload",
        value: function $preload(key, value) {
            var preloadData = cacheDataGet(PRELOAD_DATA_KEY$1) || {};
            if (_typeof(key) === "object") {
                for (var k in key) {
                    preloadData[k] = key[k];
                }
            } else {
                preloadData[key] = value;
            }
            cacheDataSet(PRELOAD_DATA_KEY$1, preloadData);
        }
        // 会被匿名函数调用
        }, {
        key: "__triggerPropsFn",
        value: function __triggerPropsFn(key, args) {
            var keyChain = key.split(".");
            var reduxFnPrefix = "__event_";
            var reduxFnName = reduxFnPrefix + keyChain.shift();
            // redux标识过的方法，直接调用
                        if (reduxFnName in this) {
                var scope = args.shift();
                var fn;
                if (keyChain.length > 0) {
                    fn = get(this[reduxFnName], keyChain.join("."));
                } else {
                    fn = this[reduxFnName];
                }
                fn.apply(scope, args);
            } else {
                // 普通的
                var keyLower = key.toLocaleLowerCase();
                var detail = {
                    __isCustomEvt: true,
                    __arguments: args
                };
                if (args.length > 0) {
                    detail.value = args.slice(1);
                }
                this.$scope.triggerEvent(keyLower, detail);
            }
        }
    } ]);
    return BaseComponent;
}();

var PureComponent = 
/* */
function(_Component) {
    _inherits(PureComponent, _Component);
    function PureComponent() {
        var _getPrototypeOf2;
        var _this;
        _classCallCheck(this, PureComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }
        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PureComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args)));
        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "isPureComponent", true);
        return _this;
    }
    _createClass(PureComponent, [ {
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps, nextState) {
            return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
        }
    } ]);
    return PureComponent;
}(BaseComponent);

function createApp(AppClass) {
    var app = new AppClass();
    var weappAppConf = {
        onLaunch: function onLaunch(options) {
            app.$app = this;
            app.$app.$router = app.$router = {
                params: options
            };
            if (app.componentWillMount) {
                app.componentWillMount();
            }
            if (app.componentDidMount) {
                app.componentDidMount();
            }
        },
        onShow: function onShow(options) {
            Object.assign(app.$router.params, options);
            if (app.componentDidShow) {
                app.componentDidShow();
            }
        },
        onHide: function onHide() {
            if (app.componentDidHide) {
                app.componentDidHide();
            }
        },
        onError: function onError(err) {
            if (app.componentDidCatchError) {
                app.componentDidCatchError(err);
            }
        },
        onPageNotFound: function onPageNotFound(obj) {
            if (app.componentDidNotFound) {
                app.componentDidNotFound(obj);
            }
        }
    };
    return Object.assign(weappAppConf, app);
}

var RequestQueue = {
    MAX_REQUEST: 5,
    queue: [],
    request: function request(options) {
        this.push(options);
        // 返回request task
                return this.run();
    },
    push: function push(options) {
        this.queue.push(options);
    },
    run: function run() {
        var _this = this;
        if (!this.queue.length) {
            return;
        }
        if (this.queue.length <= this.MAX_REQUEST) {
            var options = this.queue.shift();
            var completeFn = options.complete;
            options.complete = function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }
                completeFn && completeFn.apply(options, args);
                _this.run();
            };
            return wx.request(options);
        }
    }
};

function request(options) {
    options = options || {};
    if (typeof options === "string") {
        options = {
            url: options
        };
    }
    var originSuccess = options["success"];
    var originFail = options["fail"];
    var originComplete = options["complete"];
    var requestTask;
    var p = new Promise(function(resolve, reject) {
        options["success"] = function(res) {
            originSuccess && originSuccess(res);
            resolve(res);
        };
        options["fail"] = function(res) {
            originFail && originFail(res);
            reject(res);
        };
        options["complete"] = function(res) {
            originComplete && originComplete(res);
        };
        requestTask = RequestQueue.request(options);
    });
    p.abort = function(cb) {
        cb && cb();
        if (requestTask) {
            requestTask.abort();
        }
        return p;
    };
    return p;
}

function processApis(taro) {
    var weApis = Object.assign({}, onAndSyncApis, noPromiseApis, otherApis);
    var useDataCacheApis = {
        navigateTo: true,
        redirectTo: true,
        reLaunch: true
    };
    var routerParamsPrivateKey = "__key_";
    var preloadPrivateKey = "__preload_";
    var preloadInitedComponent = "$preloadComponent";
    Object.keys(weApis).forEach(function(key) {
        if (!onAndSyncApis[key] && !noPromiseApis[key]) {
            taro[key] = function(options) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                    args[_key2 - 1] = arguments[_key2];
                }
                options = options || {};
                var task = null;
                var obj = Object.assign({}, options);
                if (typeof options === "string") {
                    if (args.length) {
                        var _wx;
                        return (_wx = wx)[key].apply(_wx, [ options ].concat(args));
                    }
                    return wx[key](options);
                }
                if (key === "navigateTo" || key === "redirectTo" || key === "switchTab") {
                    var url = obj["url"] ? obj["url"].replace(/^\//, "") : "";
                    if (url.indexOf("?") > -1) url = url.split("?")[0];
                    var Component$$1 = cacheDataGet(url);
                    if (Component$$1) {
                        var component = new Component$$1();
                        if (component.componentWillPreload) {
                            var cacheKey = getUniqueKey();
                            var MarkIndex = obj.url.indexOf("?");
                            var params = queryToJson(obj.url.substring(MarkIndex + 1, obj.url.length));
                            obj.url += (MarkIndex > -1 ? "&" : "?") + "".concat(preloadPrivateKey, "=").concat(cacheKey);
                            cacheDataSet(cacheKey, component.componentWillPreload(params));
                            cacheDataSet(preloadInitedComponent, component);
                        }
                    }
                }
                if (useDataCacheApis[key]) {
                    var _url = obj["url"] = obj["url"] || "";
                    var _MarkIndex = _url.indexOf("?");
                    var _params = queryToJson(_url.substring(_MarkIndex + 1, _url.length));
                    var _cacheKey = getUniqueKey();
                    obj.url += (_MarkIndex > -1 ? "&" : "?") + "".concat(routerParamsPrivateKey, "=").concat(_cacheKey);
                    cacheDataSet(_cacheKey, _params);
                }
                var p = new Promise(function(resolve, reject) {
                    [ "fail", "success", "complete" ].forEach(function(k) {
                        obj[k] = function(res) {
                            options[k] && options[k](res);
                            if (k === "success") {
                                if (key === "connectSocket") {
                                    resolve(Promise.resolve().then(function() {
                                        return Object.assign(task, res);
                                    }));
                                } else {
                                    resolve(res);
                                }
                            } else if (k === "fail") {
                                reject(res);
                            }
                        };
                    });
                    if (args.length) {
                        var _wx2;
                        task = (_wx2 = wx)[key].apply(_wx2, [ obj ].concat(args));
                    } else {
                        task = wx[key](obj);
                    }
                });
                if (key === "uploadFile" || key === "downloadFile") {
                    p.progress = function(cb) {
                        if (task) {
                            task.onProgressUpdate(cb);
                        }
                        return p;
                    };
                    p.abort = function(cb) {
                        cb && cb();
                        if (task) {
                            task.abort();
                        }
                        return p;
                    };
                }
                return p;
            };
        } else {
            taro[key] = function() {
                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                    args[_key3] = arguments[_key3];
                }
                return wx[key].apply(wx, args);
            };
        }
    });
}

function pxTransform(size) {
    var _this$config = this.config, designWidth = _this$config.designWidth, deviceRatio = _this$config.deviceRatio;
    if (!(designWidth in deviceRatio)) {
        throw new Error("deviceRatio 配置中不存在 ".concat(designWidth, " 的设置！"));
    }
    return parseInt(size, 10) / deviceRatio[designWidth] + "rpx";
}

function canIUseWebp() {
    var _wx$getSystemInfoSync = wx.getSystemInfoSync(), platform = _wx$getSystemInfoSync.platform;
    var platformLower = platform.toLowerCase();
    if (platformLower === "android" || platformLower === "devtools") {
        return true;
    }
    return false;
}

function initNativeApi(taro) {
    processApis(taro);
    taro.request = request;
    taro.getCurrentPages = getCurrentPages;
    taro.getApp = getApp;
    taro.requirePlugin = requirePlugin;
    taro.initPxTransform = initPxTransform.bind(taro);
    taro.pxTransform = pxTransform.bind(taro);
    taro.canIUseWebp = canIUseWebp;
}

/* eslint-disable camelcase */ var Taro = {
    Component: BaseComponent,
    PureComponent: PureComponent,
    createApp: createApp,
    initNativeApi: initNativeApi,
    Events: Events,
    eventCenter: eventCenter,
    getEnv: getEnv,
    render: render,
    ENV_TYPE: ENV_TYPE,
    internal_safe_get: get,
    internal_safe_set: set$1,
    internal_inline_style: inlineStyle,
    createComponent: createComponent,
    internal_get_original: getOriginal,
    getElementById: getElementById
};

initNativeApi(Taro);

exports.Taro = Taro;

exports.default = Taro;
//# sourceMappingURL=index.js.map